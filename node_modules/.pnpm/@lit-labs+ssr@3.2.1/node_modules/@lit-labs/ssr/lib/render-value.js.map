{"version":3,"file":"render-value.js","sourceRoot":"","sources":["../src/lib/render-value.ts"],"names":[],"mappings":"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","sourcesContent":["/// <reference lib=\"dom\" />\n\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {TemplateResult, ChildPart, CompiledTemplateResult} from 'lit';\nimport type {\n  Directive,\n  DirectiveClass,\n  DirectiveResult,\n} from 'lit/directive.js';\n\nimport {nothing, noChange} from 'lit';\nimport {PartType} from 'lit/directive.js';\nimport {\n  isPrimitive,\n  isTemplateResult,\n  getDirectiveClass,\n  TemplateResultType,\n  isCompiledTemplateResult,\n} from 'lit/directive-helpers.js';\nimport {_$LH} from 'lit-html/private-ssr-support.js';\n\nconst {\n  getTemplateHtml,\n  marker,\n  markerMatch,\n  boundAttributeSuffix,\n  overrideDirectiveResolve,\n  setDirectiveClass,\n  getAttributePartCommittedValue,\n  resolveDirective,\n  AttributePart,\n  PropertyPart,\n  BooleanAttributePart,\n  EventPart,\n  connectedDisconnectable,\n  isIterable,\n} = _$LH;\n\nimport {digestForTemplateResult} from '@lit-labs/ssr-client';\n\nimport {\n  ElementRenderer,\n  ElementRendererConstructor,\n  getElementRenderer,\n} from './element-renderer.js';\n\nimport {escapeHtml} from './util/escape-html.js';\n\nimport {parseFragment, parse} from 'parse5';\nimport {\n  isElementNode,\n  isCommentNode,\n  traverse,\n  isTextNode,\n  isTemplateNode,\n  Template,\n  Element,\n} from '@parse5/tools';\n\nimport {isRenderLightDirective} from '@lit-labs/ssr-client/directives/render-light.js';\nimport {reflectedAttributeName} from './reflected-attributes.js';\n\nimport type {RenderResult} from './render-result.js';\nimport {isHydratable} from './server-template.js';\n\ndeclare module 'parse5/dist/tree-adapters/default.js' {\n  interface Element {\n    isDefinedCustomElement?: boolean;\n  }\n}\n\nconst patchedDirectiveCache = new WeakMap<DirectiveClass, DirectiveClass>();\n\n/**\n * Looks for values of type `DirectiveResult` and replaces its Directive class\n * with a subclass that calls `render` rather than `update`\n */\nconst patchIfDirective = (value: unknown) => {\n  // This property needs to remain unminified.\n  const directiveCtor = getDirectiveClass(value);\n  if (directiveCtor !== undefined) {\n    let patchedCtor = patchedDirectiveCache.get(directiveCtor);\n    if (patchedCtor === undefined) {\n      patchedCtor = overrideDirectiveResolve(\n        directiveCtor,\n        (directive: Directive, values: unknown[]) => {\n          // Since the return value may also be a directive result in the case of\n          // nested directives, we may need to patch that as well\n          return patchIfDirective(directive.render(...values));\n        }\n      );\n      patchedDirectiveCache.set(directiveCtor, patchedCtor);\n    }\n    // This property needs to remain unminified.\n    setDirectiveClass(value as DirectiveResult, patchedCtor);\n  }\n  return value;\n};\n\n/**\n * Patches `DirectiveResult` `Directive` classes for AttributePart values, which\n * may be an array\n */\nconst patchAnyDirectives = (\n  part: InstanceType<typeof AttributePart>,\n  value: unknown,\n  valueIndex: number\n) => {\n  if (part.strings !== undefined) {\n    for (let i = 0; i < part.strings.length - 1; i++) {\n      patchIfDirective((value as unknown[])[valueIndex + i]);\n    }\n  } else {\n    patchIfDirective(value);\n  }\n};\n\nconst templateCache = new Map<TemplateStringsArray, Array<Op>>();\n/**\n\n * Operation to output static text\n */\ntype TextOp = {\n  type: 'text';\n  value: string;\n};\n\n/**\n * Operation to output dynamic text from the associated template result value\n */\ntype ChildPartOp = {\n  type: 'child-part';\n  index: number;\n  useCustomElementInstance?: boolean;\n};\n\n/**\n * Operation to output an attribute with bindings. Includes all bindings for an\n * attribute.\n */\ntype AttributePartOp = {\n  type: 'attribute-part';\n  index: number;\n  name: string;\n  ctor: typeof AttributePart;\n  strings: Array<string>;\n  tagName: string;\n  useCustomElementInstance?: boolean;\n};\n\n/**\n * Operation for an element binding. Although we only support directives in\n * element position which cannot emit anything, the opcode needs to index past\n * the part value\n */\ntype ElementPartOp = {\n  type: 'element-part';\n  index: number;\n};\n\n/**\n * Operator to create a custom element instance.\n */\ntype CustomElementOpenOp = {\n  type: 'custom-element-open';\n  tagName: string;\n  ctor: {new (): HTMLElement};\n  staticAttributes: Map<string, string>;\n};\n\n/**\n * Operation to render a custom element's attributes. This is separate from\n * `custom-element-open` because attribute/property parts go in between and need\n * to run and be set on the instance before we render the element's final\n * attributes.\n */\ntype CustomElementAttributesOp = {\n  type: 'custom-element-attributes';\n};\n\n/**\n * Operation to render a custom element's children, usually its shadow root.\n */\ntype CustomElementShadowOp = {\n  type: 'custom-element-shadow';\n};\n\n/**\n * Operation to close a custom element so that its no longer available for\n * bindings.\n */\ntype CustomElementClosedOp = {\n  type: 'custom-element-close';\n};\n\n/**\n * Operation to possibly emit the `<!--lit-node-->` marker; the operation\n * always emits if there were attribute parts, and may emit if the node\n * was a custom element and it needed `defer-hydration` because it was\n * rendered in the shadow root of another custom element host; we don't\n * know the latter at opcode generation time, and so that test is done at\n * runtime in the opcode.\n */\ntype PossibleNodeMarkerOp = {\n  type: 'possible-node-marker';\n  boundAttributesCount: number;\n  nodeIndex: number;\n};\n\ntype Op =\n  | TextOp\n  | ChildPartOp\n  | AttributePartOp\n  | ElementPartOp\n  | CustomElementOpenOp\n  | CustomElementAttributesOp\n  | CustomElementShadowOp\n  | CustomElementClosedOp\n  | PossibleNodeMarkerOp;\n\n/**\n * For a given TemplateResult, generates and/or returns a cached list of opcodes\n * for the associated Template.  Opcodes are designed to allow emitting\n * contiguous static text from the template as much as possible, with specific\n * non-`text` opcodes interleaved to perform dynamic work, such as emitting\n * values for ChildParts or AttributeParts, and handling custom elements.\n *\n * For the following example template, an opcode list may look like this:\n *\n * ```js\n * html`<div><span>Hello</span><span class=${'bold'}>${template()}</span></div>`\n * ```\n *\n * - `text`\n *   - Emit run of static text: `<div><span>Hello</span>`\n * - `possible-node-marker`\n *   - Emit `<!--lit-node n-->` marker since there are attribute parts\n * - `text`\n *   - Emit run of static text: `<span`\n * - `attribute-part`\n *   - Emit an AttributePart's value, e.g. ` class=\"bold\"`\n * - `text`\n *   - Emit run of static text: `>`\n * - `child-part`\n *   - Emit the ChildPart's value, in this case a TemplateResult, thus we\n *     recurse into that template's opcodes\n * - `text`\n *   - Emit run of static text: `/span></div>`\n *\n * When a custom-element is encountered, the flow looks like this:\n *\n * ```js\n * html`<x-foo staticAttr dynamicAttr=${value}><div>child</div>...</x-foo>`\n * ```\n *\n * - `possible-node-marker`\n *   - Emit `<!--lit-node n-->` marker since there are attribute parts and we\n *      may emit the `defer-hydration` attribute on the node that follows\n * - `text`\n *   - Emit open tag `<x-foo`\n * - `custom-element-open`\n *   - Create the CE `instance`+`renderer` and put on\n *     `customElementInstanceStack`\n *   - Call `renderer.setAttribute()` for any `staticAttributes` (e.g.\n *     'staticAttr`)\n * - `attribute-part`(s)\n *   - Call `renderer.setAttribute()` or `renderer.setProperty()` for\n *     `AttributePart`/`PropertyPart`s (e.g. for `dynamicAttr`)\n * - `custom-element-attributes`\n *   - Call `renderer.connectedCallback()`\n *   - Emit `renderer.renderAttributes()`\n * - `text`\n *   - Emit end of of open tag `>`\n * - `custom-element-shadow`\n *   - Emit `renderer.renderShadow()` (emits `<template shadowroot>` +\n *     recurses to emit `render()`)\n * - `text`\n *   - Emit run of static text within tag: `<div>child</div>...`\n * - ...(recurse to render more parts/children)...\n * - `custom-element-close`\n *   - Pop the CE `instance`+`renderer` off the `customElementInstanceStack`\n */\nconst getTemplateOpcodes = (\n  result: TemplateResult,\n  isServerTemplate = false\n) => {\n  const template = templateCache.get(result.strings);\n  if (template !== undefined) {\n    return template;\n  }\n  const [html, attrNames] = getTemplateHtml(\n    result.strings,\n    // SVG TemplateResultType functionality is only required on the client,\n    // which instantiates SVG elements within a svg namespace. Using SVG\n    // on the server results in unneccesary svg containers being emitted.\n    TemplateResultType.HTML\n  );\n\n  const hydratable = isHydratable(result);\n\n  /**\n   * The html string is parsed into a parse5 AST with source code information\n   * on; this lets us skip over certain ast nodes by string character position\n   * while walking the AST.\n   *\n   * Server Templates need to use `parse` as they may contain document tags such\n   * as `<html>`.\n   */\n  const ast = (isServerTemplate ? parse : parseFragment)(String(html), {\n    sourceCodeLocationInfo: true,\n  });\n\n  const ops: Array<Op> = [];\n\n  /* The last offset of html written to the stream */\n  let lastOffset: number | undefined = 0;\n\n  /* Current attribute part index, for indexing attrNames */\n  let attrIndex = 0;\n\n  /**\n   * Sets `lastOffset` to `offset`, skipping a range of characters. This is\n   * useful for skipping and re-writing lit-html marker nodes, bound attribute\n   * suffix, etc.\n   */\n  const skipTo = (offset: number) => {\n    if (lastOffset === undefined) {\n      throw new Error('lastOffset is undefined');\n    }\n    if (offset < lastOffset) {\n      throw new Error(`offset must be greater than lastOffset.\n        offset: ${offset}\n        lastOffset: ${lastOffset}\n      `);\n    }\n    lastOffset = offset;\n  };\n\n  /**\n   * Records the given string to the output, either by appending to the current\n   * opcode (if already `text`) or by creating a new `text` opcode (if the\n   * previous opcode was not `text)\n   */\n  const flush = (value: string) => {\n    const op = getLast(ops);\n    if (op !== undefined && op.type === 'text') {\n      op.value += value;\n    } else {\n      ops.push({\n        type: 'text',\n        value,\n      });\n    }\n  };\n\n  /**\n   * Creates or appends to a text opcode with a substring of the html from the\n   * `lastOffset` flushed to `offset`.\n   */\n  const flushTo = (offset?: number) => {\n    if (lastOffset === undefined) {\n      throw new Error('lastOffset is undefined');\n    }\n    const previousLastOffset = lastOffset;\n    lastOffset = offset;\n    const value = String(html).substring(previousLastOffset, offset);\n    flush(value);\n  };\n\n  // Depth-first node index, counting only comment and element nodes, to match\n  // client-side lit-html.\n  let nodeIndex = 0;\n\n  traverse(ast, {\n    'pre:node'(node, parent) {\n      if (isCommentNode(node)) {\n        if (node.data === markerMatch) {\n          flushTo(node.sourceCodeLocation!.startOffset);\n          skipTo(node.sourceCodeLocation!.endOffset);\n          ops.push({\n            type: 'child-part',\n            index: nodeIndex,\n            useCustomElementInstance:\n              parent && isElementNode(parent) && parent.isDefinedCustomElement,\n          });\n        }\n        nodeIndex++;\n      } else if (isElementNode(node)) {\n        let boundAttributesCount = 0;\n\n        const tagName = node.tagName;\n\n        if (tagName.indexOf('-') !== -1) {\n          // Looking up the constructor here means that custom elements must be\n          // registered before rendering the first template that contains them.\n          const ctor = customElements.get(tagName);\n          if (ctor !== undefined) {\n            // Mark that this is a custom element\n            node.isDefinedCustomElement = true;\n            ops.push({\n              type: 'custom-element-open',\n              tagName,\n              ctor,\n              staticAttributes: new Map(\n                node.attrs\n                  .filter((attr) => !attr.name.endsWith(boundAttributeSuffix))\n                  .map((attr) => [attr.name, attr.value])\n              ),\n            });\n          }\n        }\n        const attrInfo = node.attrs.map((attr) => {\n          const isAttrBinding = attr.name.endsWith(boundAttributeSuffix);\n          const isElementBinding = attr.name.startsWith(marker);\n          if (isAttrBinding || isElementBinding) {\n            boundAttributesCount += 1;\n          }\n          return [isAttrBinding, isElementBinding, attr] as const;\n        });\n        if (boundAttributesCount > 0 || node.isDefinedCustomElement) {\n          // We (may) need to emit a `<!-- lit-node -->` comment marker to\n          // indicate the following node needs to be identified during\n          // hydration when it has bindings or if it is a custom element (and\n          // thus may need its `defer-hydration` to be removed, depending on\n          // the `deferHydration` setting). The marker is emitted as a\n          // previous sibling before the node in question, to avoid issues\n          // with void elements (which do not have children) and raw text\n          // elements (whose children are intepreted as text).\n          flushTo(node.sourceCodeLocation!.startTag!.startOffset);\n          ops.push({\n            type: 'possible-node-marker',\n            boundAttributesCount,\n            nodeIndex,\n          });\n        }\n        for (const [isAttrBinding, isElementBinding, attr] of attrInfo) {\n          if (isAttrBinding || isElementBinding) {\n            // Note that although we emit a lit-node comment marker for any\n            // nodes with bindings, we don't account for it in the nodeIndex because\n            // that will not be injected into the client template\n            const strings = attr.value.split(marker);\n            const attrSourceLocation =\n              node.sourceCodeLocation!.attrs![attr.name]!;\n            const attrNameStartOffset = attrSourceLocation.startOffset;\n            const attrEndOffset = attrSourceLocation.endOffset;\n            flushTo(attrNameStartOffset);\n            if (isAttrBinding) {\n              // We store the case-sensitive name from `attrNames` (generated\n              // while parsing the template strings); note that this assumes\n              // parse5 attribute ordering matches string ordering\n              const name = attrNames[attrIndex++];\n              const [, prefix, caseSensitiveName] = /([.?@])?(.*)/.exec(\n                name as string\n              )!;\n              if (!hydratable) {\n                if (prefix === '.') {\n                  throw new Error(\n                    `Server-only templates can't bind to properties. Bind to attributes instead, as they can be serialized when the template is rendered and sent to the browser.`\n                  );\n                } else if (prefix === '@') {\n                  throw new Error(\n                    `Server-only templates can't bind to events. There's no way to serialize an event listener when generating HTML and sending it to the browser.`\n                  );\n                }\n              }\n              ops.push({\n                type: 'attribute-part',\n                index: nodeIndex,\n                name: caseSensitiveName,\n                ctor:\n                  prefix === '.'\n                    ? PropertyPart\n                    : prefix === '?'\n                    ? BooleanAttributePart\n                    : prefix === '@'\n                    ? EventPart\n                    : AttributePart,\n                strings,\n                tagName: tagName.toUpperCase(),\n                useCustomElementInstance: node.isDefinedCustomElement,\n              });\n            } else {\n              if (!hydratable) {\n                throw new Error(`Server-only templates don't support element parts, as their API does not currently give them any way to render anything on the server. Found in template:\n    ${displayTemplateResult(result)}`);\n              }\n              ops.push({\n                type: 'element-part',\n                index: nodeIndex,\n              });\n            }\n            skipTo(attrEndOffset);\n          } else if (node.isDefinedCustomElement) {\n            // For custom elements, all static attributes are stored along\n            // with the `custom-element-open` opcode so that we can set them\n            // into the custom element instance, and then serialize them back\n            // out along with any manually-reflected attributes. As such, we\n            // skip over static attribute text here.\n            const attrSourceLocation =\n              node.sourceCodeLocation!.attrs![attr.name]!;\n            flushTo(attrSourceLocation.startOffset);\n            skipTo(attrSourceLocation.endOffset);\n          }\n        }\n\n        if (node.isDefinedCustomElement) {\n          // For custom elements, add an opcode to write out attributes,\n          // close the tag, and then add an opcode to write the shadow\n          // root\n          flushTo(node.sourceCodeLocation!.startTag!.endOffset - 1);\n          ops.push({\n            type: 'custom-element-attributes',\n          });\n          flush('>');\n          skipTo(node.sourceCodeLocation!.startTag!.endOffset);\n          ops.push({\n            type: 'custom-element-shadow',\n          });\n        } else if (\n          !hydratable &&\n          /^(title|textarea|script|style)$/.test(node.tagName)\n        ) {\n          const dangerous = isJavaScriptScriptTag(node);\n          // Marker comments in a rawtext element will be parsed as text,\n          // so we need to look at the text value of childnodes to try to\n          // find them and render child-part opcodes.\n          for (const child of node.childNodes) {\n            if (!isTextNode(child)) {\n              throw new Error(\n                `Internal error: Unexpected child node inside raw text node, a ${node.tagName} should only contain text nodes, but found a ${node.nodeName} (tagname: ${node.tagName})`\n              );\n            }\n            const text = child.value;\n            const textStart = child.sourceCodeLocation!.startOffset;\n            flushTo(textStart);\n            const markerRegex = new RegExp(marker.replace(/\\$/g, '\\\\$'), 'g');\n            for (const mark of text.matchAll(markerRegex)) {\n              flushTo(textStart + mark.index!);\n              if (dangerous) {\n                throw new Error(\n                  `Found binding inside an executable <script> tag in a server-only template. For security reasons, this is not supported, as it could allow an attacker to execute arbitrary JavaScript. If you do need to create a script element with dynamic contents, you can use the unsafeHTML directive to make one, as that way the code is clearly marked as unsafe and needing careful handling. The template with the dangerous binding is:\n\n    ${displayTemplateResult(result)}`\n                );\n              }\n              if (node.tagName === 'style') {\n                throw new Error(\n                  `Found binding inside a <style> tag in a server-only template. For security reasons, this is not supported, as it could allow an attacker to exfiltrate information from the page. If you do need to create a style element with dynamic contents, you can use the unsafeHTML directive to make one, as that way the code is clearly marked as unsafe and needing careful handling. The template with the dangerous binding is:\n\n    ${displayTemplateResult(result)}`\n                );\n              }\n              ops.push({\n                type: 'child-part',\n                index: nodeIndex,\n                useCustomElementInstance: false,\n              });\n              skipTo(textStart + mark.index! + mark[0].length);\n            }\n            flushTo(textStart + text.length);\n          }\n        } else if (!hydratable && isTemplateNode(node)) {\n          // Server-only templates look inside of <template> nodes, because\n          // we can afford the complexity and cost, and there's way more\n          // benefit to be gained from it\n          traverse(node.content, this, node);\n        }\n\n        nodeIndex++;\n      }\n    },\n    node(node) {\n      if (isElementNode(node) && node.isDefinedCustomElement) {\n        ops.push({\n          type: 'custom-element-close',\n        });\n      }\n    },\n  });\n  // Flush remaining static text in the template (e.g. closing tags)\n  flushTo();\n  templateCache.set(result.strings, ops);\n  return ops;\n};\n\nexport type RenderInfo = {\n  /**\n   * Element renderers to use\n   */\n  elementRenderers: ElementRendererConstructor[];\n\n  /**\n   * Stack of open custom elements (in light dom or shadow dom)\n   */\n  customElementInstanceStack: Array<ElementRenderer | undefined>;\n\n  /**\n   * Stack of open host custom elements (n-1 will be n's host)\n   */\n  customElementHostStack: Array<ElementRenderer | undefined>;\n\n  /**\n   * An optional callback to notify when a custom element has been rendered.\n   *\n   * This allows servers to know what specific tags were rendered for a given\n   * template, even in the case of conditional templates.\n   */\n  customElementRendered?: (tagName: string) => void;\n\n  /**\n   * Flag to defer hydration of top level custom element. Defaults to false.\n   */\n  deferHydration: boolean;\n};\n\ndeclare global {\n  interface Array<T> {\n    flat(depth: number): Array<T>;\n  }\n}\n\nexport function* renderValue(\n  value: unknown,\n  renderInfo: RenderInfo,\n  hydratable = true\n): RenderResult {\n  patchIfDirective(value);\n  if (isRenderLightDirective(value)) {\n    // If a value was produced with renderLight(), we want to call and render\n    // the renderLight() method.\n    const instance = getLast(renderInfo.customElementInstanceStack);\n    if (instance !== undefined) {\n      const renderLightResult = instance.renderLight(renderInfo);\n      if (renderLightResult !== undefined) {\n        yield* renderLightResult;\n      }\n    }\n    value = null;\n  } else {\n    value = resolveDirective(\n      connectedDisconnectable({type: PartType.CHILD}) as ChildPart,\n      value\n    );\n  }\n  if (value != null && isTemplateResult(value)) {\n    if (hydratable) {\n      yield `<!--lit-part ${digestForTemplateResult(\n        value as TemplateResult\n      )}-->`;\n    }\n    yield* renderTemplateResult(value as TemplateResult, renderInfo);\n    if (hydratable) {\n      yield `<!--/lit-part-->`;\n    }\n  } else {\n    if (hydratable) {\n      yield `<!--lit-part-->`;\n    }\n    if (\n      value === undefined ||\n      value === null ||\n      value === nothing ||\n      value === noChange\n    ) {\n      // yield nothing\n    } else if (!isPrimitive(value) && isIterable(value)) {\n      // Check that value is not a primitive, since strings are iterable\n      for (const item of value) {\n        yield* renderValue(item, renderInfo, hydratable);\n      }\n    } else {\n      yield escapeHtml(String(value));\n    }\n    if (hydratable) {\n      yield `<!--/lit-part-->`;\n    }\n  }\n}\n\nfunction* renderTemplateResult(\n  result: TemplateResult,\n  renderInfo: RenderInfo\n): RenderResult {\n  // In order to render a TemplateResult we have to handle and stream out\n  // different parts of the result separately:\n  //   - Literal sections of the template\n  //   - Defined custom element within the literal sections\n  //   - Values in the result\n  //\n  // This means we can't just iterate through the template literals and values,\n  // we must parse and traverse the template's HTML. But we don't want to pay\n  // the cost of serializing the HTML node-by-node when we already have the\n  // template in string form. So we parse with location info turned on and use\n  // that to index into the HTML string generated by TemplateResult.getHTML().\n  // During the tree walk we will handle expression marker nodes and custom\n  // elements. For each we will record the offset of the node, and output the\n  // previous span of HTML.\n\n  const hydratable = isHydratable(result);\n  const ops = getTemplateOpcodes(result, !hydratable);\n\n  /* The next value in result.values to render */\n  let partIndex = 0;\n\n  for (const op of ops) {\n    switch (op.type) {\n      case 'text':\n        yield op.value;\n        break;\n      case 'child-part': {\n        const value = result.values[partIndex++];\n        let isValueHydratable = hydratable;\n        if (isTemplateResult(value)) {\n          isValueHydratable = isHydratable(value);\n          if (!isValueHydratable && hydratable) {\n            throw new Error(\n              `A server-only template can't be rendered inside an ordinary, hydratable template. A server-only template can only be rendered at the top level, or within other server-only templates. The outer template was:\n    ${displayTemplateResult(result)}\n\nAnd the inner template was:\n    ${displayTemplateResult(value)}\n              `\n            );\n          }\n        }\n        yield* renderValue(value, renderInfo, isValueHydratable);\n        break;\n      }\n      case 'attribute-part': {\n        const statics = op.strings;\n        const part = new op.ctor(\n          // Passing only object with tagName for the element is fine since the\n          // directive only gets PartInfo without the node available in the\n          // constructor\n          {tagName: op.tagName} as HTMLElement,\n          op.name,\n          statics,\n          connectedDisconnectable(),\n          {}\n        );\n        const value =\n          part.strings === undefined ? result.values[partIndex] : result.values;\n        patchAnyDirectives(part, value, partIndex);\n        let committedValue: unknown = noChange;\n        // Values for EventParts are never emitted\n        if (!(part.type === PartType.EVENT)) {\n          committedValue = getAttributePartCommittedValue(\n            part,\n            value,\n            partIndex\n          );\n        }\n        // We don't emit anything on the server when value is `noChange` or\n        // `nothing`\n        if (committedValue !== noChange) {\n          const instance = op.useCustomElementInstance\n            ? getLast(renderInfo.customElementInstanceStack)\n            : undefined;\n          if (part.type === PartType.PROPERTY) {\n            yield* renderPropertyPart(instance, op, committedValue);\n          } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n            // Boolean attribute binding\n            yield* renderBooleanAttributePart(instance, op, committedValue);\n          } else {\n            yield* renderAttributePart(instance, op, committedValue);\n          }\n        }\n        partIndex += statics.length - 1;\n        break;\n      }\n      case 'element-part': {\n        // We don't emit anything for element parts (since we only support\n        // directives for now; since they can't render, we don't even bother\n        // running them), but we still need to advance the part index\n        partIndex++;\n        break;\n      }\n      case 'custom-element-open': {\n        // Instantiate the element and its renderer\n        const instance = getElementRenderer(\n          renderInfo,\n          op.tagName,\n          op.ctor,\n          op.staticAttributes\n        );\n        // Set static attributes to the element renderer\n        for (const [name, value] of op.staticAttributes) {\n          instance.setAttribute(name, value);\n        }\n        renderInfo.customElementInstanceStack.push(instance);\n        renderInfo.customElementRendered?.(op.tagName);\n        break;\n      }\n      case 'custom-element-attributes': {\n        const instance = getLast(renderInfo.customElementInstanceStack);\n        if (instance === undefined) {\n          throw new Error(\n            `Internal error: ${op.type} outside of custom element context`\n          );\n        }\n        // Perform any connect-time work via the renderer (e.g. reflecting any\n        // properties to attributes, for example)\n        if (instance.connectedCallback) {\n          instance.connectedCallback();\n        }\n        // Render out any attributes on the instance (both static and those\n        // that may have been dynamically set by the renderer)\n        yield* instance.renderAttributes();\n        // If deferHydration flag is true or if this element is nested in\n        // another, add the `defer-hydration` attribute, so that it does not\n        // enable before the host element hydrates\n        if (\n          renderInfo.deferHydration ||\n          renderInfo.customElementHostStack.length > 0\n        ) {\n          yield ' defer-hydration';\n        }\n        break;\n      }\n      case 'possible-node-marker': {\n        // Add a node marker if this element had attribute bindings or if it\n        // was nested in another and we rendered the `defer-hydration` attribute\n        // since the hydration node walk will need to stop at this element\n        // to hydrate it\n        if (\n          op.boundAttributesCount > 0 ||\n          renderInfo.customElementHostStack.length > 0\n        ) {\n          if (hydratable) {\n            yield `<!--lit-node ${op.nodeIndex}-->`;\n          }\n        }\n        break;\n      }\n      case 'custom-element-shadow': {\n        const instance = getLast(renderInfo.customElementInstanceStack);\n        if (instance === undefined) {\n          throw new Error(\n            `Internal error: ${op.type} outside of custom element context`\n          );\n        }\n        renderInfo.customElementHostStack.push(instance);\n        const shadowContents = instance.renderShadow(renderInfo);\n        // Only emit a DSR if renderShadow() emitted something (returning\n        // undefined allows effectively no-op rendering the element)\n        if (shadowContents !== undefined) {\n          const {mode = 'open', delegatesFocus} =\n            instance.shadowRootOptions ?? {};\n          // `delegatesFocus` is intentionally allowed to coerce to boolean to\n          // match web platform behavior.\n          const delegatesfocusAttr = delegatesFocus\n            ? ' shadowrootdelegatesfocus'\n            : '';\n          yield `<template shadowroot=\"${mode}\" shadowrootmode=\"${mode}\"${delegatesfocusAttr}>`;\n          yield* shadowContents;\n          yield '</template>';\n        }\n        renderInfo.customElementHostStack.pop();\n        break;\n      }\n      case 'custom-element-close':\n        renderInfo.customElementInstanceStack.pop();\n        break;\n      default:\n        throw new Error('internal error');\n    }\n  }\n\n  if (partIndex !== result.values.length) {\n    throwErrorForPartIndexMismatch(partIndex, result);\n  }\n}\n\nfunction throwErrorForPartIndexMismatch(\n  partIndex: number,\n  result: TemplateResult\n) {\n  const errorMsg = `\n    Unexpected final partIndex: ${partIndex} !== ${\n    result.values.length\n  } while processing the following template:\n\n    ${displayTemplateResult(result)}\n\n    This could be because you're attempting to render an expression in an invalid location. See\n    https://lit.dev/docs/templates/expressions/#invalid-locations for more information about invalid expression\n    locations.\n  `;\n\n  throw new Error(errorMsg);\n}\n\nfunction* renderPropertyPart(\n  instance: ElementRenderer | undefined,\n  op: AttributePartOp,\n  value: unknown\n) {\n  value = value === nothing ? undefined : value;\n  // Property should be reflected to attribute\n  const reflectedName = reflectedAttributeName(op.tagName, op.name);\n  if (instance !== undefined) {\n    instance.setProperty(op.name, value);\n  }\n  if (reflectedName !== undefined) {\n    yield `${reflectedName}=\"${escapeHtml(String(value))}\"`;\n  }\n}\n\nfunction* renderBooleanAttributePart(\n  instance: ElementRenderer | undefined,\n  op: AttributePartOp,\n  value: unknown\n) {\n  if (value && value !== nothing) {\n    if (instance !== undefined) {\n      instance.setAttribute(op.name, '');\n    } else {\n      yield op.name;\n    }\n  }\n}\n\nfunction* renderAttributePart(\n  instance: ElementRenderer | undefined,\n  op: AttributePartOp,\n  value: unknown\n) {\n  if (value !== nothing) {\n    if (instance !== undefined) {\n      instance.setAttribute(op.name, String(value ?? ''));\n    } else {\n      yield `${op.name}=\"${escapeHtml(String(value ?? ''))}\"`;\n    }\n  }\n}\n\n/**\n * Returns a debug string suitable for an error message describing a\n * TemplateResult.\n */\nfunction displayTemplateResult(\n  result: TemplateResult | CompiledTemplateResult\n) {\n  if (isCompiledTemplateResult(result)) {\n    return result._$litType$.h.join('${...}');\n  }\n  return result.strings.join('${...}');\n}\n\nconst getLast = <T>(a: Array<T>) => a[a.length - 1];\n\n/**\n * Returns true if the given node is a <script> node that the browser will\n * automatically execute if it's rendered on server-side, outside of a\n * <template> tag.\n */\nfunction isJavaScriptScriptTag(node: Element | Template): boolean {\n  function isScriptTag(node: Element | Template): node is Element {\n    return /script/i.test(node.tagName);\n  }\n\n  if (!isScriptTag(node)) {\n    return false;\n  }\n  let safeTypeSeen = false;\n  for (const attr of node.attrs) {\n    if (attr.name !== 'type') {\n      continue;\n    }\n    switch (attr.value) {\n      // see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#textjavascript\n      case null:\n      case undefined:\n      case '':\n      case 'module':\n      case 'text/javascript':\n      case 'application/javascript':\n      case 'application/ecmascript':\n      case 'application/x-ecmascript':\n      case 'application/x-javascript':\n      case 'text/ecmascript':\n      case 'text/javascript1.0':\n      case 'text/javascript1.1':\n      case 'text/javascript1.2':\n      case 'text/javascript1.3':\n      case 'text/javascript1.4':\n      case 'text/javascript1.5':\n      case 'text/jscript':\n      case 'text/livescript':\n      case 'text/x-ecmascript':\n      case 'text/x-javascript':\n        // If we see a dangerous type, we can stop looking\n        return true;\n      default:\n        safeTypeSeen = true;\n    }\n  }\n  // So, remember that attributes can be repeated. If we saw a dangerous type,\n  // then we would have returned early. However, if there's no type, then\n  // that's dangerous.\n  // It's only if all types seen were safe, and we saw at least one type, that\n  // we can return false.\n  const willExecute = !safeTypeSeen;\n  return willExecute;\n}\n"]}